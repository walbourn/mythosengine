//
//
//                                                           %__________%
//                                                          %/ . .  .   \%
//           Van Gogh 2D-Display Library                     |  . .  o. | 
//                                                           |. _  .   .|
//          Microsoft Windows '95 Version                    | / \   .  | 
//                                                           |_|_|_._._.|
// Copyright (c) 1994, 1995 by Charybdis Enterprises, Inc.   |.-.-.-.-..|
//              All rights reserved.                        %\__________/%
//                                                           %          %
//
//
//
//           *** Charybdis Enterprises, Inc. Company Confidential ***
//
//  This file and all associated files are the company proprietary property
//        of Charybdis Enterprises, Inc.  Unauthorized use prohibited.
//
// CHARYBDIS ENTERPRISES, INC. MAKES NO WARRANTIES, EXPRESS OR IMPLIED, AS
// TO THE CORRECTNESS OF THIS CODE OR ANY DERIVATIVE WORKS WHICH INCORPORATE
// IT.  CHARYBDIS ENTERPRISES, INC. PROVIDES THE CODE ON AN "AS-IS" BASIS
// AND EXPLICITLY DISCLAIMS ANY LIABILITY, INCLUDING CONSEQUENTIAL AND
// INCIDENTAL DAMAGES FOR ERRORS, OMISSIONS, AND OTHER PROBLEMS IN THE CODE.
//
//
//
// vngvp8.cpp
//
//     The C pluss pluss 8bpp view port classes.
//
// Revision History 
//

//
//
//                                Includes
//                                
//

#include <string.h>
#include <assert.h>
#include "debug.h"
#include "portable.h"
#include "ivory.h"
#include "vangogh.hpp"

//
//
//                                Equates
//
//

#define MIN(a,b)  ((a) < (b)) ? (a) : (b)  
                     
//
//
//                               Structures
//
//

//
//
//                               Routines
//
//

//
//
//                                 Data
//
//

//
//
//                                 Code
//
//


//Ŀ
//                                                                          
// This is the constructor of the VngoVport8 class.  It initializes all of  
// the data needed to draw into an 8bit device.                             
//                                                                          
//

//Ŀ
//                                                                          
// This is the Virtual View Port stuff.                                     
//                                                                          
//


VngoVportDD8::VngoVportDD8 (long width,long height,void *vbptr,void *zbptr,VngoPal *my_pal,dword flags)
{
    init_status = init (width,height,vbptr,zbptr,my_pal,flags);
}

vngo_error_codes VngoVportDD8::init (long width,long height,void *vbptr,void *zbptr,VngoPal *my_pal,dword flags)
{
    vbuff.width = width;
    vbuff.height = height;
    vbuff.left = 0;
    vbuff.top = 0;
    vflags = flags;
    vflags |= VNGO_PAL_MAPPED_DEV;
    size_in_bytes = width * height;
    vbuff.zbuff_ptr = (dword *)zbptr;
    damage_list = NULL;
    last_damage_list = NULL;

    vbuff.scrn_ptr = (byte *)vbptr;
    if (vbuff.scrn_ptr == NULL)
    {
        vbuff.scrn_ptr = (byte *)ivory_alloc (size_in_bytes);
        vflags |= VNGO_MYMEM_VBUFF;
    }
    if (!vbuff.scrn_ptr)
    {
            return (VNGO_MEMALLOC_ERROR);
    }

    if (vflags & VNGO_ZBUFFER_DEV)
    {
        vzdepth_in_bits = 16;
        int z_size_shift = vzdepth_in_bits >> 4;
        if (vbuff.zbuff_ptr == NULL)
        {
            vbuff.zbuff_ptr = (dword *)ivory_alloc(size_in_bytes << z_size_shift);
            vflags |= VNGO_MYMEM_ZBUFF;
        }
        if (!vbuff.zbuff_ptr)
        {
            if (vflags & VNGO_MYMEM_VBUFF)
                ivory_free((void **)&(vbuff.scrn_ptr));
            return (VNGO_MEMALLOC_ERROR);
        }
        assert(vbuff.zbuff_ptr != 0);
        vflags |= VNGO_ZBUFFER_ACTIVE;
    }

    // allocate all tables.

    vbuff.ytable = (dword *)ivory_alloc(4096 * sizeof(dword));
    if (!vbuff.ytable)
    {
        if ((vflags & VNGO_ZBUFFER_DEV) && (vflags & VNGO_MYMEM_ZBUFF))
        {
            if (vflags & VNGO_MYMEM_VBUFF)
                ivory_free((void **)&(vbuff.scrn_ptr));
            ivory_free((void **)&(vbuff.zbuff_ptr));
        }
        return (VNGO_MEMALLOC_ERROR);
    }
    vbuff.invert = (dword *)ivory_alloc(4096 * sizeof(dword));
    if (!vbuff.invert)
    {
        if ((vflags & VNGO_ZBUFFER_DEV) && (vflags & VNGO_MYMEM_ZBUFF))
        {
            if (vflags & VNGO_MYMEM_VBUFF)
                ivory_free((void **)&(vbuff.scrn_ptr));
            ivory_free((void **)&(vbuff.zbuff_ptr));
        }
        ivory_free((void **)&(vbuff.ytable));
        return (VNGO_MEMALLOC_ERROR);
    }

    if (my_pal)
    {
        vbuff.pal = my_pal;
    }
    else
    {
        // here you will normaly build a new default palette.
        vbuff.pal = NULL;
    }

    // Fill all tables.
    vngo_fill_y_table(&vbuff, 1);
    vngo_fill_invert_table(vbuff.invert);

    if (!(vflags & VNGO_INIT_NO_RESET))
    {
        reset();
    }
    return (VNGO_NO_ERROR);
}

VngoVportDD8::~VngoVportDD8()
{
    if ((vflags & VNGO_MYMEM_VBUFF) && (vbuff.scrn_ptr))
    {
        ivory_free((void **)&(vbuff.scrn_ptr));
    }
    vbuff.scrn_ptr = NULL;
    if ((vflags & VNGO_ZBUFFER_DEV) && (vflags & VNGO_MYMEM_ZBUFF))
    {
        if (vbuff.zbuff_ptr)
        {
            ivory_free((void **)&(vbuff.zbuff_ptr));
        }
    }
    vbuff.zbuff_ptr = NULL;
    if (vbuff.ytable)
    {
        ivory_free((void **)&(vbuff.ytable));
    }
    if (vbuff.invert)
    {
        ivory_free((void **)&(vbuff.invert));
    }
}



// End of module - vngbase.cpp 
